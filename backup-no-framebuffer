// =============================================================================
// Setup
// =============================================================================

let orbitCenter, orbitPan, orbitTilt, orbitDistance, alien, desert, landscape, house, skybox, projectionXform, blaster, astronautb, astronauth;
{
    // Interactivity ///////////////////////////////////////////////////////////

    orbitCenter = Sticky("orbitCenter", Vec3.all(0));
    orbitPan = Sticky("orbitPan", -0.8);
    orbitTilt = Sticky("orbitTilt", -0.2);
    orbitDistance = Sticky("orbitDistance", 20);

    onMouseDrag((e) => {
        orbitPan.update((v) => v - e.movementX * 0.01);
        orbitTilt.update((v) => glance.clamp(v - e.movementY * 0.01, -Math.PI / 2, Math.PI / 2));
    });

    onMouseWheel((e) => {
        orbitDistance.update((v) => glance.clamp(v * (1 + e.deltaY * 0.001), 2.0, 18.0));
    });

    onKeyDown((e) => {
        if (e.key === "ArrowRight") {
            orbitCenter.update((v) => v.set(3.8, 0.1, 1.6));
        } else if (e.key === "ArrowLeft") {
            orbitCenter.update((v) => v.set(4, 0, -4));
        }
    });

    onKeyDown((e) => {
        if (e.key === "ArrowRight") {
            orbitCenter.update((v) => v.set(3.8, 0.1, 1.6));
        } else if (e.key === "ArrowLeft") {
            orbitCenter.update((v) => v.set(4, 0, -4));
        }
    });


    projectionXform = glance.Mat4.perspective(Math.PI / 4, gl.canvas.width / gl.canvas.height, 0.1, 30);
    onResize(() => {
        projectionXform.perspective(Math.PI / 4, gl.canvas.width / gl.canvas.height, 0.1, 30);
    });

    // Scene Setup /////////////////////////////////////////////////////////////


const vsSource = `#version 300 es
    precision highp float;

    uniform mat4 u_modelXform;
    uniform mat4 u_viewXform;
    uniform mat4 u_projectionXform;
    uniform vec3 u_viewPosition;

    in vec3 a_pos;
    in vec3 a_normal;
    in vec3 a_tangent;
    in vec2 a_texCoord;

    out vec3 f_worldPos;
    out vec3 f_viewPosition;
    out vec2 f_texCoord;
    out mat3 f_TBN;

    void main() {
        vec3 normal = normalize((u_modelXform * vec4(a_normal, 0.0)).xyz);
        vec3 tangent = normalize((u_modelXform * vec4(a_tangent, 0.0)).xyz);
        vec3 bitangent = cross(normal, tangent);
        
        f_TBN = mat3(tangent, bitangent, normal);
        
        vec4 worldPosition = u_modelXform * vec4(a_pos, 1.0);
        f_worldPos = worldPosition.xyz;
        f_viewPosition = u_viewPosition;
        f_texCoord = a_texCoord;
        
        gl_Position = u_projectionXform * u_viewXform * worldPosition;
    }
`;

const fsSource = `#version 300 es
    precision mediump float;

    uniform float u_ambient;
    uniform float u_specularPower;
    uniform float u_specularIntensity;
    uniform sampler2D u_diffuse;
    uniform sampler2D u_normal;

    in vec3 f_worldPos;
    in vec3 f_viewPosition;
    in vec2 f_texCoord;
    in mat3 f_TBN;

    out vec4 o_fragColor;

    void main() {
        // Get normal from normal map and transform to [-1, 1] range
        vec3 normalMap = texture(u_normal, f_texCoord).rgb * 2.0 - 1.0;
        vec3 normal = normalize(f_TBN * normalMap);
        
        // Calculate view and light directions
        vec3 viewDir = normalize(f_viewPosition - f_worldPos);
        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); // Static light direction
        
        // Calculate half vector for specular
        vec3 halfwayDir = normalize(lightDir + viewDir);
        
        // Calculate lighting components
        float diffuse = max(dot(normal, lightDir), 0.0);
        float specular = pow(max(dot(normal, halfwayDir), 0.0), u_specularPower);
        
        // Sample diffuse texture
        vec4 texColor = texture(u_diffuse, f_texCoord);
        
        // Combine lighting
        vec3 ambient = u_ambient * texColor.rgb;
        vec3 diffuseColor = diffuse * texColor.rgb;
        vec3 specularColor = specular * u_specularIntensity * vec3(1.0);
        
        o_fragColor = vec4(ambient + diffuseColor + specularColor, texColor.a);
    }
`;

const normalMapProgram = glance.createProgram(gl, "normal-map-shader", vsSource, fsSource);



alien = await glance.createBPGeometry(gl,
    "Abgabe/Assets/alienb/alienChar.obj",
    { 
        diffuse: "Abgabe/Assets/alienb/Alien_low_AlienHominid_BaseColor.png",
        normal: "Abgabe/Assets/alienb/Alien_low_AlienHominid_Normal.png"
    },
    { 
        renderNormals: true,
        calculateTangents: true,  
        program: normalMapProgram   
    }   
    );
    alien.uniform.u_ambient = 0.4;
    alien.uniform.u_specularPower = 64;
    alien.uniform.u_specularIntensity = 0.1;

    // Blaster--------------------------------------------------------------------------------
      blaster = await glance.createBPGeometry(gl,
        "Abgabe/Assets/alienb/gun.obj",
        { diffuse: "Abgabe/Assets/alienb/Blaster_Blaster_BaseColor.png" },
        { renderNormals: true },
    );
    blaster.uniform.u_ambient = 0.4;
    blaster.uniform.u_specularPower = 64;
    blaster.uniform.u_specularIntensity = 0.3;
 
    // Character Astronaut Body------------------------------------------------------------------------------
    astronautb = await glance.createBPGeometry(gl,
        "Abgabe/Assets/astrounaut/astronaut-body.obj",
        { diffuse: "Abgabe/Assets/astrounaut/suit_DIFF2.png" },
        { renderNormals: true },
    );
    astronautb.uniform.u_ambient = 0.4;
    astronautb.uniform.u_specularPower = 64;
    astronautb.uniform.u_specularIntensity = 0.3;

    // Character Astronaut helmet------------------------------------------------------------------------------
    astronauth = await glance.createBPGeometry(gl,
        "Abgabe/Assets/astrounaut/astronaut-helmet.obj",
        {  },
        { renderNormals: true },
    );
    astronauth.uniform.u_ambient = 0.4;
    astronauth.uniform.u_specularPower = 64;
    astronauth.uniform.u_specularIntensity = 0.3;

    // Fahrzeug -----------------------------------------------------------------------------
    desert = await glance.createBPGeometry(gl,
        "Abgabe/Assets/Car/icetruck.obj",
        { diffuse: "Abgabe/Assets/Car/car_ice.png"},
        { renderNormals: true },
    );
    desert.uniform.u_ambient = 0.35;
    desert.uniform.u_specularPower = 8;
    desert.uniform.u_specularIntensity = 0.3;
    desert.uniform.u_modelXform = glance.Mat4.identity();
   
    landscape = await glance.createBPGeometry(gl,
        "Abgabe/Assets/Landscape/mars.obj",
        { 
            diffuse: "Abgabe/Assets/Landscape/colormap-mars.jpg",
            normal: "Abgabe/Assets/Landscape/normalmap.jpg" 
        },
        { 
            renderNormals: true,
            calculateTangents: true,
            program: normalMapProgram
        }
    );

    // Building -----------------------------------------------------------------------------

    house = await glance.createBPGeometry(gl,
        "Abgabe/Assets/Buildings/building.obj",
        {
            diffuse: "Abgabe/Assets/Buildings/Architecture3_DefaultMaterial_BaseColor.png",
        },
        { renderNormals: true },
    );
    house.uniform.u_ambient = 0.15;
    house.uniform.u_specularPower = 64;
    house.uniform.u_specularIntensity = 0.1;

    skybox = await glance.createSkybox(gl,
        [
            "Abgabe/Assets/skybox/corona_ft.png",
            "Abgabe/Assets/skybox/corona_bk.png",
            "Abgabe/Assets/skybox/corona_up.png",
            "Abgabe/Assets/skybox/corona_dn.png",
            "Abgabe/Assets/skybox/corona_rt.png",
            "Abgabe/Assets/skybox/corona_lf.png",
        ],
        { renderNormals: true },
    );
}

// =============================================================================
// Render Loop
// =============================================================================

/// Most of the changing uniforms are the same for all draw calls, so we can
/// simplify the setup by assigning uniforms & rendering each draw call in a loop.
function renderScene(viewPos, viewXform) {
    for (const drawCall of [house, alien, desert, skybox, blaster, landscape, astronautb, astronauth]) {
        drawCall.uniform.u_viewXform = viewXform;
        drawCall.uniform.u_projectionXform = projectionXform;
        
        if (drawCall !== skybox) {
            drawCall.uniform.u_viewPosition = viewPos;
        }
        glance.draw(gl, drawCall);
    }
}


// The main render loop.
function myRenderLoop({ time, globalTime }) {
    // Update the item positions (in this case, just the alien)
    //alien.uniform.u_modelXform = glance.Mat4.translateY(Math.sin(globalTime / 800) * 0.1).rotateY(globalTime / 5000);


    

    // Clear the default framebuffer before drawing on it.
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Calculate uniforms that are the same for all draw calls to the default framebuffer.
    const viewPos = glance.Vec3.translateZ(orbitDistance.get()).rotateX(orbitTilt.get()).rotateY(orbitPan.get()).add(orbitCenter.getRef());
    const viewXform = glance.Mat4.lookAt(viewPos, orbitCenter.getRef(), glance.Vec3.yAxis());

    // Render the scene again, this time in the default framebuffer.
    renderScene(viewPos, viewXform);
}
setRenderLoop(myRenderLoop);